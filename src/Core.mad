import type { Query } from "@/Query"
import type { Tag } from "@/Tag"

import { now, toISOString } from "Date"

import { colorize } from "Dye"

import { Tag, serialize } from "@/Tag"



/**
 * The condition of when a side-effect should run
 * @since 0.0.1
 */
export alias PartyPredicate a = Tag -> String -> a -> Boolean

/**
 * The side-effect to run
 * @since 0.0.1
 */
export alias SideEffect b = String -> b -> b

/**
 * The message decoration
 * @since 0.0.1
 */
export alias Decorator a = Tag -> String -> a -> String

/**
 * The configuration of the signal
 * @since 0.0.1
 */
export alias Config = {
  change :: a -> b,
  check :: PartyPredicate a,
  decorate :: Decorator a,
  effect :: SideEffect b,
}

/**
 * The core function that does all the magic of PartyBus.
 * Conditionally call a side-effect with a specific tag, message and value.
 * @since 0.0.1
 */
signalWithConfig :: Config -> Tag -> String -> a -> a
export signalWithConfig = (conf, tag, message, x) => {
  return where(conf) {
    { decorate, effect, change, check } =>
      do {
        msg = decorate(tag, message, x)
        return if (check(tag, msg, x)) do {
          effect(msg, change(x))
          return x
        } else {
          x
        }
      }
  }
}

/**
 * A shorthand function to always fire the side-effect
 * @since 0.0.1
 */
always :: PartyPredicate a
export always = (_, _, _) => true

/**
 * A shorthand function to pass the message unchanged
 * @since 0.0.1
 */
decorateRaw :: Decorator a
export decorateRaw = (_, m, _) => m


/**
 * A means of colorizing a message by tag
 * @since 0.0.1
 */
colorizeTag :: Tag -> String
export colorizeTag = pipe(
  serialize,
  (tagId) => colorize(tagId, " " ++ tagId ++ " "),
)

/**
 * Color by tag and prepend to message
 * @since 0.0.1
 */
decorateWithStyle :: Decorator a
export decorateWithStyle = (tag, message, _) => {
  idWithColor = colorizeTag(tag)
  return idWithColor ++ " " ++ message
}

/**
 * Color by tag, add current time and prepend to message
 * @since 0.0.1
 */
decorateWithStyleAndDate :: Decorator a
export decorateWithStyleAndDate = (tag, message, _) => {
  idWithColor = colorizeTag(tag)
  return idWithColor ++ " " ++ toISOString(now()) ++ " â–¸ " ++ message
}

// (this currently has an issue)
/**
 * A sugar method to create a Config record, usually by partial application 
 * @since 0.0.1
 */
configurate :: Decorator a -> SideEffect b -> (a -> b) -> PartyPredicate a -> Config
export configurate = (decorate, effect, change, check) => ({ decorate, effect, change, check })

export confDecorator = (decorate, conf) => (
  { decorate, effect: conf.effect, change: conf.change, check: conf.check }
)

export confEffect = (effect, conf) => (
  { decorate: conf.decorate, effect, change: conf.change, check: conf.check }
)

export confChange = (change, conf) => (
  { change, decorate: conf.decorate, effect: conf.effect, check: conf.check }
)

export confCheck = (check, conf) => (
  { check, decorate: conf.decorate, effect: conf.effect, change: conf.change }
)
