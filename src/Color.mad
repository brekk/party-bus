import { ge } from "Compare"
import Float from "Float"
import { identity } from "Function"
import Integer from "Integer"
import Random from "Random"
import Term from "Terminal"

import {
  ANSI_BACKGROUND,
  ANSI_FOREGROUND,
  FULL_COLOR_CHANNEL,
  HALF_COLOR_CHANNEL,
} from "@/Color/Constants"
import { channelB, channelG, channelR } from "@/Color/Math"
import { colorFromSeed } from "@/Color/Random"



export alias Color a = #[a, a, a]
export BLACK = #[0, 0, 0]
export WHITE = #[FULL_COLOR_CHANNEL, FULL_COLOR_CHANNEL, FULL_COLOR_CHANNEL]

// derive Comparable Color a

export toChannel = where {
  #[r, g, b] =>
    r | g | b
}

export toInteger = where {
  #[r, g, b] =>
    r + g + b
}

export toFloat = where {
  #[r, g, b] =>
    16 + (36 * (r / 255 * 5)) + (6 * (g / 255 * 5)) + (b / 255 * 5)
}

export fromFloat = (v) => {
  r = channelR(v)
  g = channelG(v)
  b = channelB(v)
  return #[r, g, b]
}


toList :: Color a -> List a
export toList = where {
  #[r, g, b] =>
    [r, g, b]
}

mixer :: (Color a -> Color a -> Color b) -> Color a -> Color a -> Color b
export mixer = (mix, a, b) => mix(a, b)

mapRGB :: (a -> b) -> (a -> b) -> (a -> b) -> Color a -> Color b
export mapRGB = (fnR, fnG, fnB, a) => where(a) {
  #[r, g, b] =>
    #[fnR(r), fnG(g), fnB(b)]
}

export mapR = mapRGB($, identity, identity)
export mapG = mapRGB(identity, $, identity)
export mapB = mapRGB(identity, identity, $)

change :: (a -> b) -> Color a -> Color b
export change = (fn, a) => mapRGB(fn, fn, fn)(a)

export toTupleFloat = change(Integer.toFloat)

export toTupleInt = change(Float.toInteger)

export invert = (x) => FULL_COLOR_CHANNEL - x

export rgbInvert = change(invert)

isMid = ge($, HALF_COLOR_CHANNEL)

luminance :: Color Float -> Color Float
export luminance = mapRGB((r) => r * 0.2126, (g) => g * 0.7152, (b) => b * 0.0722)

isLuminous :: Color Float -> Boolean
isLuminous = pipe(
  luminance,
  toInteger,
  isMid,
)

seeded :: String -> String -> List String
export seeded = (seedPrefix, str) => pipe(
  mappend(seedPrefix),
  Random.generateFromString,
  colorFromSeed,
  (color) => {
    black = pipe(
      toTupleFloat,
      isLuminous,
    )(color)
    return where(color) {
      #[r, g, b] =>
        do {
          blackChannel = black ? 0 : FULL_COLOR_CHANNEL
          return map(show)([
            ANSI_FOREGROUND,
            2,
            blackChannel,
            blackChannel,
            blackChannel,
            ANSI_BACKGROUND,
            2,
            r,
            g,
            b,
          ])
        }
    }
  },
)(str)

contrastByLuminance :: Color Float -> Color Float
export contrastByLuminance = pipe(
  luminance,
  toFloat,
  (x) => !isMid(x) ? WHITE : BLACK,
)
