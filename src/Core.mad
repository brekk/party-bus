import type { Tag } from "@/Tag/Type"

import { now, toISOString } from "Date"
import Dict from "Dictionary"
import { identity } from "Function"
import IO from "IO"

import { colorize } from "Dye"

import { serialize } from "@/Tag"
import { Tag } from "@/Tag/Type"



export alias PartyPredicate a = Tag -> String -> a -> Boolean
export alias SideEffect b = String -> b -> b
export alias MessageModifier a = Tag -> String -> a -> String

signalWithWhen :: MessageModifier a
  -> SideEffect b
  -> (a -> b)
  -> PartyPredicate a
  -> Tag
  -> String
  -> a
  -> a
export signalWithWhen = (modMessage, effect, change, check, tag, message, x) => {
  msg = modMessage(tag, message, x)
  return if (!check(tag, msg, x)) {
    x
  } else do {
    effect(msg, change(x))
    return x
  }
}

export invokeWithWhen = signalWithWhen((_, m, _) => m)

colorizeTag :: Tag -> String
colorizeTag = pipe(
  serialize,
  (tagId) => colorize(tagId, " " ++ tagId ++ " "),
)

styleTag :: MessageModifier a
export styleTag = (tag, message, _) => {
  idWithColor = colorizeTag(tag)
  return idWithColor ++ " " ++ message
}

styleTagWithTime :: MessageModifier a
export styleTagWithTime = (tag, message, _) => {
  idWithColor = colorizeTag(tag)
  return idWithColor ++ " " ++ toISOString(now()) ++ " â–¸ " ++ message
}

export callWithWhen = signalWithWhen(styleTag)
export datedWithWhen = signalWithWhen(styleTagWithTime)

always :: PartyPredicate a
export always = (_, _, _) => true


// invoke always, with a specific scope
export invokeWith = invokeWithWhen($, $, always)
// invoke sometimes, with no change in scope
export invokeWhen = invokeWithWhen($, identity, $)
// invoke always, with no change in scope
export invoke = invokeWithWhen($, identity, always)

export callWith = callWithWhen($, $, always)
export callWhen = callWithWhen($, identity, $)
export call = callWithWhen($, identity, always)

export datedTrace = datedWithWhen(IO.pTrace)
export datedWith = datedWithWhen($, $, always)
export datedWhen = datedWithWhen($, identity, $)
export dated = datedWithWhen($, identity, always)
// nearly drop-in-replacement for IO.pTrace, with tagged and dated messages
export dTrace = dated(IO.pTrace)

// common aliases with logging
export traceWith = callWith(IO.pTrace)
export traceWhen = callWhen(IO.pTrace)
// nearly drop-in-replacement for IO.pTrace, with tagged messages
export trace = call(IO.pTrace)

tagFactoryWithWhen :: Show b => SideEffect b
  -> (a -> b)
  -> PartyPredicate a
  -> List Tag
  -> Dictionary Tag (SideEffect a)
export tagFactoryWithWhen = (effect, change, when, tags) => pipe(
  map((tag) => #[tag, datedWithWhen(effect, change, when, tag)]),
  Dict.fromList,
)(tags)

export traceFactoryWithWhen = tagFactoryWithWhen(IO.pTrace)
export traceFactoryWhen = traceFactoryWithWhen(identity)
export traceFactoryWith = traceFactoryWithWhen($, always)
